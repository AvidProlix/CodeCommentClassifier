from string import punctuation
import re
import os

# holds constants needed across py files, and the Classes for FileContent and Comments

# the directory that this python script is running from
INSTALLATION_DIRECTORY = os.path.dirname(os.path.realpath(__file__))

# class labels in both lookup directions
labelMap = {"summary":0, "deprecation":1, "usage":2, "exception":3, "todo":4, 
            "incomplete":5, "commentedCode":6, "autogenerated":7, "noise":8, 
            "warning":9, "recommendation":10, "codingGuidelines":11, 
            "subclassExplaination":12, "complexity":13, "debug":14 } 
commentLabel = ["summary", "deprecation", "usage", "exception", "todo", 
            "incomplete", "commentedCode", "autogenerated", "noise", 
            "warning", "recommendation", "codingGuidelines", 
            "subclassExplaination", "complexity", "debug"]

# article words to remove from comments
articleList = ["an","and","the"]

# take the raw text of the comment and strip down to lowercase a-z only
def cleanComment(comment):
    comment = re.sub('\d','', comment) # remove numbers
    comment = comment.replace("\n", "") # Remove newlines
    comment = comment.lower() # lowercase
    comment = "".join([ch for ch in comment if ch not in punctuation]) # remove punctuation
    comment = re.sub(' . ','', comment) # remove single letters (variables)
    comment = re.sub(' +', ' ', comment) # remove multi-space
    comment = comment.strip() # remove leading and trailing whitespace
    return comment

# comment class
class Comment:
    def __init__(self, line_number, file_name, comment):
        self.line_number = line_number
        self.file_name = file_name
        self.comment = comment
        self.comment_tokenized = []
        self.label = ""
        self.label_id = 0
        self.confidence = 0

# file that contains none or more comments
class FileContent:
    def __init__(self, file_path, num_lines):
        self.comments = []
        self.file_path = file_path
        self.num_lines = num_lines
        self.file_name = file_path.split("\\")[-1]

    def add_comment(self, comment:Comment):
        self.comments.append(comment)

    # returns a string that contains the file's comments information
    def score_message(self):
        # init scores for file
        warnings = exceptions = todos = incompletes = deprecations =0
        critical_comment_count = 0

        # count critical label occurrences
        for com in self.comments:
            if com.labelId == labelMap["warning"]:
                warnings += 1
            if com.labelId == labelMap["exception"]:
                exceptions += 1
            if com.labelId == labelMap["todo"]:
                todos += 1
            if com.labelId == labelMap["incomplete"]:
                incompletes += 1
            if com.labelId == labelMap["deprecation"]:
                deprecations += 1

        critical_comment_count = warnings + exceptions + todos + incompletes + deprecations

        # if there are lines, and there is at least one critical comment
        if(self.num_lines > 0 and critical_comment_count > 0):
            dataline = ''
            if warnings > 0:
                dataline += ('\033[91m' + 'warnings: {} ' +  '\033[0m').format(warnings)
            if incompletes > 0:
                dataline += ('\033[92m' + 'incompletes: {} ' +  '\033[0m').format(incompletes)
            if exceptions > 0:
                dataline += ('\033[93m' + 'exceptions: {} ' +  '\033[0m').format(exceptions)
            if todos > 0:
                dataline += ('\033[94m' + 'todos: {} ' +  '\033[0m').format(todos)
            if deprecations > 0:
                dataline += ('\033[95m' + 'deprecations: {}' +  '\033[0m').format(deprecations)
            return dataline
        return None
